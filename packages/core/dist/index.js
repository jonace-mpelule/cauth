import e,{Algorithm as t}from"@node-rs/argon2";import n,{z as r}from"zod";import{parsePhoneNumberFromString as i}from"libphonenumber-js";import a from"node:crypto";import o from"jsonwebtoken";var s=class{static LoginPurpose=`LOGIN`;static ResetPasswordPurpose=`RESET_PASSWORD`;static ActionPurpose=`ACTION`};const c=r.string().trim().refine(e=>{let t=i(e);return!!t&&t.isValid()},{message:`Invalid phone number`}).transform(e=>i(e)?.format(`E.164`)??e),l=r.enum([`LOGIN`,`RESET_PASSWORD`,`ACTION`]),u=r.object({email:r.email(),phoneNumber:r.never().optional(),password:r.string().min(6).optional()}),d=r.object({phoneNumber:c,email:r.never().optional(),password:r.string().min(6).optional()}),f=r.union([u,d]).superRefine((e,t)=>{e.email&&e.phoneNumber&&t.addIssue({code:r.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),p=r.object({phoneNumber:c,email:r.never().optional(),code:r.string().min(4).max(8)}),m=r.object({email:r.email(),phoneNumber:r.never().optional(),code:r.string().min(4).max(8)}),h=r.union([m,p]),g=r.object({otpPurpose:l,usePassword:r.boolean().default(!1),password:r.string().optional()}),_=g.extend({phoneNumber:c,email:r.never().optional()}),v=g.extend({phoneNumber:r.never().optional(),email:r.string().email()});r.union([_,v]).refine(e=>e.usePassword?!!e.password:!e.password,{message:`Password required only if usePassword is true`,path:[`password`]});const y=r.object({phoneNumber:c.optional(),email:r.email().optional(),role:r.string(),password:r.string().optional()}).superRefine((e,t)=>{!e.email&&!e.phoneNumber&&t.addIssue({code:r.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),b=r.object({refreshToken:r.string()}),x=r.object({refreshToken:r.string()}),S=r.object({accountId:r.string(),oldPassword:r.string(),newPassword:r.string()});var C=class{static ValidationError=`validation-error`;static CredentialError=`credential-error`;static UnKnownError=`unknown-error`;static InvalidDataError=`invalid-data-error`},w=class{static ServerError=`internal-server-error`;static ServerErrorMessage=`Internal server error. We are working to fix this, please try again later`;static InvalidToken=`invalid-token`;static InvalidTokenMessage=`Invalid Token`;static ForbiddenResource=`forbidden-resource`;static ForbiddenResourceMessage=`You don't have sufficient permission for this action`;static InvalidOtp=`invalid-otp`;static InvalidOtpMessage=`Invalid Otp. Please check and try again`;static CredentialMismatch=`credential-mismatch`;static CredentialMismatchMessage=`Credential mismatch. Please check your credentials and try again.`;static InvalidData=`invalid-data`;static InvalidDataMessage=e=>`Invalid Body: ${e}`;static AccountNotFound=`account-not-found`;static AccountNotFoundMessage=`Account not found`;static InvalidRole=`invalid-role`;static InvalidRoleMessage=e=>`Role is invalid, please use one of the following roles: ${e.join(`, `)}`;static InvalidRefreshToken=`invalid-refresh-token`;static InvalidRefreshTokenMessage=`Invalid refresh token`;static DuplicateAccount=`account-already-exists`;static DuplicateAccountMessage=`Account with this credentials already exists`;static SchemaValidationError=`schema-validation`;static SchemaValidationMessage=`Your database error is not is sync with CAuth Spec`};const T={CredentialMismatchError:{type:C.CredentialError,message:w.CredentialMismatchMessage,code:w.CredentialMismatch,name:`CredentialMismatchError`},InvalidDataError:e=>({type:C.ValidationError,message:w.InvalidDataMessage(e),code:w.InvalidData,name:`InvalidDataError`}),AccountNotFoundError:{type:C.InvalidDataError,message:w.AccountNotFoundMessage,code:w.AccountNotFound,name:`AccountNotFoundError`},InvalidRoleError:e=>({type:C.ValidationError,message:w.InvalidRoleMessage(e),code:w.InvalidRole,name:`InvalidRoleError`}),InvalidRefreshTokenError:{type:C.ValidationError,message:w.InvalidRefreshTokenMessage,code:w.InvalidRefreshToken,name:`InvalidRefreshTokenError`},DuplicateAccountError:{type:C.ValidationError,message:w.DuplicateAccountMessage,code:w.DuplicateAccount,name:`DuplicateAccountError`},InvalidOTPCode:{type:C.ValidationError,message:w.InvalidOtpMessage,code:w.InvalidOtp,name:`InvalidOTPCode`},SchemaInvalidError:{type:C.ValidationError,message:w.SchemaValidationMessage,code:w.SchemaValidationError,name:`SchemaInvalidError`}};function E(e,t){return typeof e==`object`&&!!e&&`name`in e&&e.name===t}function D(e,t){return E(e,t)}function O(e){return{success:!0,value:e}}function k(...e){return{success:!1,errors:e}}function A(e){return`${e?.error?.issues[0].path}: ${e?.error?.issues[0].message}`}async function j({config:t},{...n}){let r=f.safeParse({email:n.email,phoneNumber:n.phoneNumber});if(!r.success)return k({error:T.InvalidDataError(A(r))});let i=await t.dbContractor.findAccountWithCredential({phoneNumber:n.phoneNumber,email:n.email});if(!i||n.usePassword&&!await e.verify(String(n.password),String(i?.passwordHash)))return k({error:T.CredentialMismatchError});let a=await t.dbContractor.createOTP({config:t},{id:i.id,purpose:n.otpPurpose});return n.onCode(a.code),O({id:i.id})}async function M({config:e,tokens:t},n){let r=h.safeParse({phoneNumber:n.phoneNumber,email:n.email,code:n.code});if(!r.success)return k({error:T.InvalidDataError(A(r))});let i=await e.dbContractor.findAccountWithCredential({email:n.email,phoneNumber:n.phoneNumber});if(!i)return k({error:T.CredentialMismatchError});if(!(await e.dbContractor.verifyOTP({id:i.id,code:n.code,purpose:s.LoginPurpose})).isValid)return k({error:T.InvalidOTPCode});let a=await t.GenerateTokenPairs({id:i.id,role:i.role});return await e.dbContractor.updateAccountLogin({id:i.id,refreshToken:a.refreshToken,config:e}),delete i.passwordHash,delete i.refreshTokens,O({account:i,tokens:a})}async function N({config:e},t){return O({isValid:(await e.dbContractor.verifyOTP({id:t.id,code:t.code,purpose:t.otpPurpose})).isValid})}async function P({config:n},{...r}){let i=S.safeParse(r);if(!i.success)return k({error:T.InvalidDataError(A(i))});let a=await n.dbContractor.findAccountById({id:r.accountId});if(!a||!await e.verify(String(r.oldPassword),String(a.passwordHash)))return k({error:T.CredentialMismatchError});let o=await e.hash(r.newPassword,{algorithm:t.Argon2id});return await n.dbContractor.updateAccount({id:a.id,data:{passwordHash:o}}),O({})}async function F({config:t,tokens:n},{...r}){let i=f.safeParse(r);if(!i.success)return k({error:T.InvalidDataError(A(i))});let a=await t.dbContractor.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber});if(!a||!await e.verify(String(r.password),String(a?.passwordHash)))return k({error:T.CredentialMismatchError});let o=await n.GenerateTokenPairs({id:a.id,role:a.role});return await t.dbContractor.updateAccountLogin({id:a.id,refreshToken:o.refreshToken,config:t}),delete a.passwordHash,delete a.refreshTokens,O({account:a,tokens:o})}async function I(e){try{return{data:await e,error:null}}catch(e){return{data:null,error:e}}}async function L({config:e,tokens:t},{...n}){let r=x.safeParse(n);if(!r.success)return k({error:T.InvalidDataError(A(r))});let i=await I(t.VerifyRefreshToken(n.refreshToken));return i.error||!i?k({error:T.InvalidRefreshTokenError}):(await e.dbContractor.removeAndAddRefreshToken({id:String(i.data?.id),refreshToken:n.refreshToken}),O({}))}function R({token:e,refreshTokenSecret:t}){return a.createHmac(`sha256`,t).update(e).digest(`hex`)}function z({incomingToken:e,storedHash:t,refreshTokenSecret:n}){let r=R({token:e,refreshTokenSecret:n});return a.timingSafeEqual(Buffer.from(r),Buffer.from(t))}async function B({config:e,tokens:t},{...n}){let r=b.safeParse(n);if(!r.success)return k({error:T.InvalidDataError(A(r))});let i=await I(t.VerifyRefreshToken(n.refreshToken));if(i.error)return k({error:T.InvalidRefreshTokenError});let a=await e.dbContractor.findAccountById({id:String(i.data?.id)});if(!a)return k({error:T.AccountNotFoundError});if(!a?.refreshTokens?.some(t=>z({incomingToken:n.refreshToken,storedHash:t.token,refreshTokenSecret:e.jwtConfig.refreshTokenSecret})))return k({error:T.InvalidRefreshTokenError});let o=await t.GenerateTokenPairs({id:a.id,role:a.role});return await e.dbContractor.removeAndAddRefreshToken({id:a.id,refreshToken:n.refreshToken,newRefreshToken:o.refreshToken}),delete a.refreshTokens,delete a.passwordHash,O({account:a,tokens:o})}async function V({config:n,tokens:r},{...i}){let a=y.safeParse(i);if(!a.success)return k({error:T.InvalidDataError(A(a))});if(!n.roles?.includes(i.role))return k({error:T.InvalidRoleError(n.roles)});if(await n.dbContractor.findAccountWithCredential({email:i.email,phoneNumber:i.phoneNumber}))return k({error:T.DuplicateAccountError});let o=await e.hash(String(i.password),{algorithm:t.Argon2i}),s=await n.dbContractor.createAccount({data:{email:i.email,phoneNumber:i.phoneNumber,passwordHash:o,role:i.role,lastLogin:new Date}}),c=await r.GenerateTokenPairs({id:s.id,role:s.role});return await n.dbContractor.updateAccountLogin({id:s.id,refreshToken:c.refreshToken,config:n}),O({account:s,tokens:c})}async function H({...e}){return o.sign(e.payload,e.config.jwtConfig.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`})}async function U({...e}){return o.sign(e.payload,e.config.jwtConfig.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`})}async function W({...e}){return{accessToken:o.sign(e.payload,e.config.jwtConfig.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`}),refreshToken:o.sign(e.payload,e.config.jwtConfig.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`})}}async function G({...e}){let t=o.verify(e.token,e.config.jwtConfig.refreshTokenSecret);return t instanceof String?null:t}async function K({...e}){let t=o.verify(e.token,e.config.jwtConfig.accessTokenSecret);return t instanceof String?null:t}const q=n.custom(()=>!0,{message:`Invalid dbContractor: must implement Database Contract interface`}),J=n.custom(()=>!0,{message:`Invalid routeContractor: must implement RoutesContract interface`}),Y=n.custom(),X=n.object({dbContractor:q,routeContractor:J,roles:n.array(n.string()).min(1),jwtConfig:n.object({refreshTokenSecret:n.string(),accessTokenSecret:n.string(),accessTokenLifeSpan:Y.optional(),refreshTokenLifeSpan:Y.optional()}),otpConfig:n.object({expiresIn:n.number().optional(),length:n.number().min(4).max(8).optional()})});var Z=class{#config;constructor(e){if(!X.safeParse(e).success)throw Error(`âŒ Failed to initiate CAuth. You provided an invalid config!`);this.#config=e}get RoleType(){return null}Guard=e=>this.#config.routeContractor.Guard({config:this.#config,tokens:this.Tokens,roles:e});Routes={Register:()=>this.#config.routeContractor.Register({config:this.#config,tokens:this.Tokens}),Login:()=>this.#config.routeContractor.Login({config:this.#config,tokens:this.Tokens}),Logout:()=>this.#config.routeContractor.Logout({config:this.#config,tokens:this.Tokens}),Refresh:()=>this.#config.routeContractor.Refresh({config:this.#config,tokens:this.Tokens}),ChangePassword:e=>this.#config.routeContractor.ChangePassword({config:this.#config,tokens:this.Tokens,userId:e})};FN={Login:({...e})=>F({config:this.#config,tokens:this.Tokens},e),Register:({...e})=>V({config:this.#config,tokens:this.Tokens},e),Logout:({...e})=>L({config:this.#config,tokens:this.Tokens},e),Refresh:({...e})=>B({config:this.#config,tokens:this.Tokens},e),ChangePassword:({...e})=>P({config:this.#config,tokens:this.Tokens},e),RequestOTPCode:({...e})=>j({config:this.#config,tokens:this.Tokens},e),LoginWithOTP:e=>M({config:this.#config,tokens:this.Tokens},e),VerifyOTP:e=>N({config:this.#config,tokens:this.Tokens},e)};Tokens={GenerateRefreshToken:e=>U({payload:e,config:this.#config}),GenerateAccessToken:e=>H({payload:e,config:this.#config}),GenerateTokenPairs:e=>W({payload:e,config:this.#config}),VerifyRefreshToken:e=>G({token:e,config:this.#config}),VerifyAccessToken:e=>K({token:e,config:this.#config})}};function Q(e){return new Z(e)}export{Q as CAuth,T as CAuthErrors,D as is,E as isCAuthError};