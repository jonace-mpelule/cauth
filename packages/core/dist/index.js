import e from"argon2";import t,{z as n}from"zod";import{parsePhoneNumberFromString as r}from"libphonenumber-js";import i from"node:crypto";import a from"jsonwebtoken";var o=class{static LoginPurpose=`LOGIN`;static ResetPasswordPurpose=`RESET_PASSWORD`;static ActionPurpose=`ACTION`};const s=n.string().trim().refine(e=>{let t=r(e);return!!t&&t.isValid()},{message:`Invalid phone number`}).transform(e=>r(e)?.format(`E.164`)??e),c=n.enum([`LOGIN`,`RESET_PASSWORD`,`ACTION`]),l=n.object({email:n.email(),phoneNumber:n.never().optional(),password:n.string().min(6).optional()}),u=n.object({phoneNumber:s,email:n.never().optional(),password:n.string().min(6).optional()}),d=n.union([l,u]).superRefine((e,t)=>{e.email&&e.phoneNumber&&t.addIssue({code:n.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),f=n.object({phoneNumber:s,email:n.never().optional(),code:n.string().min(4).max(8)}),p=n.object({email:n.email(),phoneNumber:n.never().optional(),code:n.string().min(4).max(8)}),m=n.union([p,f]),h=n.object({otpPurpose:c,usePassword:n.boolean().default(!1),password:n.string().optional()}),g=h.extend({phoneNumber:s,email:n.never().optional()}),_=h.extend({phoneNumber:n.never().optional(),email:n.string().email()});n.union([g,_]).refine(e=>e.usePassword?!!e.password:!e.password,{message:`Password required only if usePassword is true`,path:[`password`]});const v=n.object({phoneNumber:s.optional(),email:n.email().optional(),role:n.string(),password:n.string().optional()}).superRefine((e,t)=>{!e.email&&!e.phoneNumber&&t.addIssue({code:n.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),y=n.object({refreshToken:n.string()}),b=n.object({refreshToken:n.string()}),x=n.object({accountId:n.string(),oldPassword:n.string(),newPassword:n.string()});var S=class{static ValidationError=`validation-error`;static CredentialError=`credential-error`;static UnKnownError=`unknown-error`;static InvalidDataError=`invalid-data-error`},C=class{static ServerError=`internal-server-error`;static ServerErrorMessage=`Internal server error. We are working to fix this, please try again later`;static InvalidToken=`invalid-token`;static InvalidTokenMessage=`Invalid Token`;static ForbiddenResource=`forbidden-resource`;static ForbiddenResourceMessage=`You don't have sufficient permission for this action`;static InvalidOtp=`invalid-otp`;static InvalidOtpMessage=`Invalid Otp. Please check and try again`;static CredentialMismatch=`credential-mismatch`;static CredentialMismatchMessage=`Credential mismatch. Please check your credentials and try again.`;static InvalidData=`invalid-data`;static InvalidDataMessage=e=>`Invalid Body: ${e}`;static AccountNotFound=`account-not-found`;static AccountNotFoundMessage=`Account not found`;static InvalidRole=`invalid-role`;static InvalidRoleMessage=e=>`Role is invalid, please use one of the following roles: ${e.join(`, `)}`;static InvalidRefreshToken=`invalid-refresh-token`;static InvalidRefreshTokenMessage=`Invalid refresh token`;static DuplicateAccount=`account-already-exists`;static DuplicateAccountMessage=`Account with this credentials already exists`;static SchemaValidationError=`schema-validation`;static SchemaValidationMessage=`Your database error is not is sync with CAuth Spec`};const w={CredentialMismatchError:{type:S.CredentialError,message:C.CredentialMismatchMessage,code:C.CredentialMismatch,name:`CredentialMismatchError`},InvalidDataError:e=>({type:S.ValidationError,message:C.InvalidDataMessage(e),code:C.InvalidData,name:`InvalidDataError`}),AccountNotFoundError:{type:S.InvalidDataError,message:C.AccountNotFoundMessage,code:C.AccountNotFound,name:`AccountNotFoundError`},InvalidRoleError:e=>({type:S.ValidationError,message:C.InvalidRoleMessage(e),code:C.InvalidRole,name:`InvalidRoleError`}),InvalidRefreshTokenError:{type:S.ValidationError,message:C.InvalidRefreshTokenMessage,code:C.InvalidRefreshToken,name:`InvalidRefreshTokenError`},DuplicateAccountError:{type:S.ValidationError,message:C.DuplicateAccountMessage,code:C.DuplicateAccount,name:`DuplicateAccountError`},InvalidOTPCode:{type:S.ValidationError,message:C.InvalidOtpMessage,code:C.InvalidOtp,name:`InvalidOTPCode`},SchemaInvalidError:{type:S.ValidationError,message:C.SchemaValidationMessage,code:C.SchemaValidationError,name:`SchemaInvalidError`}};function T(e,t){return typeof e==`object`&&!!e&&`name`in e&&e.name===t}function E(e,t){return T(e,t)}function D(e){return{success:!0,value:e}}function O(...e){return{success:!1,errors:e}}function k(e){return`${e?.error?.issues[0].path}: ${e?.error?.issues[0].message}`}async function A({config:t},{...n}){let r=d.safeParse({email:n.email,phoneNumber:n.phoneNumber});if(!r.success)return O({error:w.InvalidDataError(k(r))});let i=await t.dbContractor.findAccountWithCredential({phoneNumber:n.phoneNumber,email:n.email});if(!i||n.usePassword&&!await e.verify(String(n.password),String(i?.passwordHash)))return O({error:w.CredentialMismatchError});let a=await t.dbContractor.createOTP({config:t},{id:i.id,purpose:n.otpPurpose});return n.onCode(a.code),D({id:i.id})}async function j({config:e,tokens:t},n){let r=m.safeParse({phoneNumber:n.phoneNumber,email:n.email,code:n.code});if(!r.success)return O({error:w.InvalidDataError(k(r))});let i=await e.dbContractor.findAccountWithCredential({email:n.email,phoneNumber:n.phoneNumber});if(!i)return O({error:w.CredentialMismatchError});if(!(await e.dbContractor.verifyOTP({id:i.id,code:n.code,purpose:o.LoginPurpose})).isValid)return O({error:w.InvalidOTPCode});let a=await t.GenerateTokenPairs({id:i.id,role:i.role});return await e.dbContractor.updateAccountLogin({id:i.id,refreshToken:a.refreshToken,config:e}),delete i.passwordHash,delete i.refreshTokens,D({account:i,tokens:a})}async function M({config:e},t){return D({isValid:(await e.dbContractor.verifyOTP({id:t.id,code:t.code,purpose:t.otpPurpose})).isValid})}async function N({config:t},{...n}){let r=x.safeParse(n);if(!r.success)return O({error:w.InvalidDataError(k(r))});let i=await t.dbContractor.findAccountById({id:n.accountId});if(!i||!await e.verify(String(n.oldPassword),String(i.passwordHash)))return O({error:w.CredentialMismatchError});let a=await e.hash(n.newPassword,{type:e.argon2id});return await t.dbContractor.updateAccount({id:i.id,data:{passwordHash:a}}),D({})}async function P({config:t,tokens:n},{...r}){let i=d.safeParse(r);if(!i.success)return O({error:w.InvalidDataError(k(i))});let a=await t.dbContractor.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber});if(!a||!await e.verify(String(r.password),String(a?.passwordHash)))return O({error:w.CredentialMismatchError});let o=await n.GenerateTokenPairs({id:a.id,role:a.role});return await t.dbContractor.updateAccountLogin({id:a.id,refreshToken:o.refreshToken,config:t}),delete a.passwordHash,delete a.refreshTokens,D({account:a,tokens:o})}async function F(e){try{return{data:await e,error:null}}catch(e){return{data:null,error:e}}}async function I({config:e,tokens:t},{...n}){let r=b.safeParse(n);if(!r.success)return O({error:w.InvalidDataError(k(r))});let i=await F(t.VerifyRefreshToken(n.refreshToken));return i.error||!i?O({error:w.InvalidRefreshTokenError}):(await e.dbContractor.removeAndAddRefreshToken({id:String(i.data?.id),refreshToken:n.refreshToken}),D({}))}function L({token:e,refreshTokenSecret:t}){return i.createHmac(`sha256`,t).update(e).digest(`hex`)}function R({incomingToken:e,storedHash:t,refreshTokenSecret:n}){let r=L({token:e,refreshTokenSecret:n});return i.timingSafeEqual(Buffer.from(r),Buffer.from(t))}async function z({config:e,tokens:t},{...n}){let r=y.safeParse(n);if(!r.success)return O({error:w.InvalidDataError(k(r))});let i=await F(t.VerifyRefreshToken(n.refreshToken));if(i.error)return O({error:w.InvalidRefreshTokenError});let a=await e.dbContractor.findAccountById({id:String(i.data?.id)});if(!a)return O({error:w.AccountNotFoundError});if(!a?.refreshTokens?.some(t=>R({incomingToken:n.refreshToken,storedHash:t.token,refreshTokenSecret:e.jwtConfig.refreshTokenSecret})))return O({error:w.InvalidRefreshTokenError});let o=await t.GenerateTokenPairs({id:a.id,role:a.role});return await e.dbContractor.removeAndAddRefreshToken({id:a.id,refreshToken:n.refreshToken,newRefreshToken:o.refreshToken}),delete a.refreshTokens,delete a.passwordHash,D({account:a,tokens:o})}async function B({config:t,tokens:n},{...r}){let i=v.safeParse(r);if(!i.success)return O({error:w.InvalidDataError(k(i))});if(!t.roles?.includes(r.role))return O({error:w.InvalidRoleError(t.roles)});if(await t.dbContractor.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber}))return O({error:w.DuplicateAccountError});let a=await e.hash(String(r.password),{type:e.argon2id}),o=await t.dbContractor.createAccount({data:{email:r.email,phoneNumber:r.phoneNumber,passwordHash:a,role:r.role,lastLogin:new Date}}),s=await n.GenerateTokenPairs({id:o.id,role:o.role});return await t.dbContractor.updateAccountLogin({id:o.id,refreshToken:s.refreshToken,config:t}),D({account:o,tokens:s})}async function V({...e}){return a.sign(e.payload,e.config.jwtConfig.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`})}async function H({...e}){return a.sign(e.payload,e.config.jwtConfig.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`})}async function U({...e}){return{accessToken:a.sign(e.payload,e.config.jwtConfig.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`}),refreshToken:a.sign(e.payload,e.config.jwtConfig.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`})}}async function W({...e}){let t=a.verify(e.token,e.config.jwtConfig.refreshTokenSecret);return t instanceof String?null:t}async function G({...e}){let t=a.verify(e.token,e.config.jwtConfig.accessTokenSecret);return t instanceof String?null:t}const K=t.custom(()=>!0,{message:`Invalid dbContractor: must implement Database Contract interface`}),q=t.custom(()=>!0,{message:`Invalid routeContractor: must implement RoutesContract interface`}),J=t.custom(),Y=t.object({dbContractor:K,routeContractor:q,roles:t.array(t.string()).min(1),jwtConfig:t.object({refreshTokenSecret:t.string(),accessTokenSecret:t.string(),accessTokenLifeSpan:J.optional(),refreshTokenLifeSpan:J.optional()}),otpConfig:t.object({expiresIn:t.number().optional(),length:t.number().min(4).max(8).optional()})});var X=class{#config;constructor(e){if(!Y.safeParse(e).success)throw Error(`âŒ Failed to initiate CAuth. You provided an invalid config!`);this.#config=e}get RoleType(){return null}Guard=e=>this.#config.routeContractor.Guard({config:this.#config,tokens:this.Tokens,roles:e});Routes={Register:()=>this.#config.routeContractor.Register({config:this.#config,tokens:this.Tokens}),Login:()=>this.#config.routeContractor.Login({config:this.#config,tokens:this.Tokens}),Logout:()=>this.#config.routeContractor.Logout({config:this.#config,tokens:this.Tokens}),Refresh:()=>this.#config.routeContractor.Refresh({config:this.#config,tokens:this.Tokens}),ChangePassword:e=>this.#config.routeContractor.ChangePassword({config:this.#config,tokens:this.Tokens,userId:e})};FN={Login:({...e})=>P({config:this.#config,tokens:this.Tokens},e),Register:({...e})=>B({config:this.#config,tokens:this.Tokens},e),Logout:({...e})=>I({config:this.#config,tokens:this.Tokens},e),Refresh:({...e})=>z({config:this.#config,tokens:this.Tokens},e),ChangePassword:({...e})=>N({config:this.#config,tokens:this.Tokens},e),RequestOTPCode:({...e})=>A({config:this.#config,tokens:this.Tokens},e),LoginWithOTP:e=>j({config:this.#config,tokens:this.Tokens},e),VerifyOTP:e=>M({config:this.#config,tokens:this.Tokens},e)};Tokens={GenerateRefreshToken:e=>H({payload:e,config:this.#config}),GenerateAccessToken:e=>V({payload:e,config:this.#config}),GenerateTokenPairs:e=>U({payload:e,config:this.#config}),VerifyRefreshToken:e=>W({token:e,config:this.#config}),VerifyAccessToken:e=>G({token:e,config:this.#config})}};function Z(e){return new X(e)}export{Z as CAuth,w as CAuthErrors,E as is,T as isCAuthError};